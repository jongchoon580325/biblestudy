# 카테고리 ID 정책: 사람이 읽을 수 있는 ID 사용 권고

## 1. 정책 개요

- 카테고리 ID는 반드시 사람이 읽을 수 있는 고정값(예: `genesis`, `exodus`, `old-testament`, `new-testament`)만 사용한다.
- 동적으로 생성되는 랜덤/UUID 기반의 ID(`1749158421122-la463ac34` 등)는 금지한다.
- 카테고리 추가/수정/삭제 시에도 네이밍 룰을 엄격히 관리한다.

---

## 2. 정책 도입 배경 및 필요성

### 2.1 백업/복구, 이식성
- 내보내기/가져오기, 데이터 마이그레이션, 환경 이전 시 ID와 name이 일치하므로 참조 무결성 유지가 쉽다.
- csv/json 등으로 내보내도 사람이 바로 이해할 수 있고, 수동 편집/수정이 용이하다.

### 2.2 코드/로직 단순화
- 카테고리 ID와 name이 명확히 매핑되어, 복구 시 ID 충돌/중복 문제 발생 가능성이 낮다.
- 여러 환경에서 동일한 ID로 일관성 있게 관리 가능하다.

### 2.3 장기 유지보수
- 신규 기능 추가, 외부 시스템 연동, 데이터 마이그레이션 등에서 예측 가능성이 높다.
- 협업 및 장기 운영 시 실수/버그 가능성이 현저히 줄어든다.

---

## 3. 동적/랜덤 ID 정책의 문제점

- 내보내기/가져오기 시 ID가 환경마다 달라질 수 있어 참조 무결성(리소스.category ↔ 카테고리.id)이 깨질 위험이 있다.
- 복구 시 ID 매핑 테이블을 별도로 관리해야 하며, 기존 데이터와 신규 데이터의 ID가 다르면 참조가 꼬일 수 있다.
- 사람이 직접 데이터 편집/이관 시 불편하고, 장기적으로 데이터 꼬임, 복구 불가, 이관 불가 등 심각한 문제를 유발한다.

---

## 4. 실무적 권고 및 운영 방침

- 카테고리 ID는 사람이 읽을 수 있는 고정값만 사용한다.
- 내보내기/가져오기, 복구 로직은 이 ID를 기준으로 설계한다.
- 이미 동적 ID로 생성된 데이터는 마이그레이션 스크립트로 일괄 변환한다.
- 카테고리 관리 UI/로직에서도 ID 중복/오타 방지 정책을 적용한다.

---

## 5. 결론

- 사람이 읽을 수 있는 ID 정책이 백업/복구, 이식성, 유지보수, 협업 모든 면에서 압도적으로 안정적이다.
- 동적 ID 정책은 장기적으로 반드시 데이터 꼬임, 복구 불가, 이관 불가 등 심각한 문제를 유발한다.

**따라서, 카테고리 ID는 사람이 읽을 수 있는 값으로 통일하고, 모든 데이터 관리 및 백업/복구 로직도 이 기준으로 설계할 것을 강력히 권고한다.** 